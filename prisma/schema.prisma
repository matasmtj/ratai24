generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model City {
  id                     Int                     @id @default(autoincrement())
  name                   String                  @unique
  country                String
  cars                   Car[]
  contactOperationAreas  ContactOperationArea[]
  demandMetrics          CityDemandMetrics?
  pricingSnapshots       PricingSnapshot[]
  seasonalFactors        SeasonalFactor[]
  pricingRules           PricingRule[]
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
}

model Car {
  id                Int        @id @default(autoincrement())
  vin               String     @unique                      // NEW: global unique
  numberPlate       String     @unique                      // NEW: usually unique per country; we keep global unique
  make              String
  model             String
  year              Int
  pricePerDay       Float                                   // Legacy fixed price (fallback)
  // Sale-related fields
  availableForLease Boolean    @default(true)
  availableForSale  Boolean    @default(false)
  salePrice         Decimal?   @db.Decimal(10, 2)
  saleDescription   String?    @db.Text                    // Description/comment for sale listing
  
  // Dynamic Pricing Configuration
  useDynamicPricing     Boolean   @default(true)
  basePricePerDay       Float?                              // Calculated base cost
  minPricePerDay        Float?                              // Floor price (never go below)
  maxPricePerDay        Float?                              // Ceiling price (never exceed)
  
  // Cost structure for pricing calculation
  dailyOperatingCost    Float?                              // Insurance + maintenance + parking per day
  monthlyFinancingCost  Float?                              // Loan/lease payment per month
  purchasePrice         Float?                              // Original purchase price (for depreciation)
  
  // Performance tracking
  utilizationRate       Float?    @default(0)               // Cached value, updated daily
  averageRevenuePerDay  Float?                              // Rolling average
  lastUtilizationUpdate DateTime?
  
  // Maintenance status affects pricing
  lastMaintenanceDate   DateTime?
  nextMaintenanceKm     Int?
  maintenanceScore      Float?    @default(100)             // 0-100, affects price
  
  cityId            Int
  city              City       @relation(fields: [cityId], references: [id], onDelete: Cascade)
  contracts         Contract[]
  images            CarImage[]
  pricingSnapshots  PricingSnapshot[]
  pricingRules      PricingRule[]
  seatCount         Int        @default(5)
  fuelType          FuelType
  powerKW           Int
  engineCapacityL   Float?
  bodyType          BodyType
  gearbox           Gearbox
  state             CarState   @default(AVAILABLE)
  odometerKm        Int        @default(0)
  colour            String?    // Optional car color
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @default(now()) @updatedAt

  // REMOVE the old composite unique (no longer needed)
  // @@unique([make, model, year, cityId], name: "unique_car_in_city")
}

model CarImage {
  id        Int      @id @default(autoincrement())
  carId     Int
  car       Car      @relation(fields: [carId], references: [id], onDelete: Cascade)
  filename  String   // stored filename (e.g., "abc123.jpg")
  url       String   // public URL or path (e.g., "/uploads/abc123.jpg")
  isMain    Boolean  @default(false)
  order     Int      @default(0) // order of the image in the gallery
  createdAt DateTime @default(now())

  @@index([carId])
}

model Contract {
  id                Int           @id @default(autoincrement())
  userId            Int
  carId             Int
  startDate         DateTime
  endDate           DateTime
  totalPrice        Float
  car               Car           @relation(fields: [carId], references: [id], onDelete: Cascade)
  state             ContractState @default(ACTIVE)
  mileageStartKm    Int
  mileageEndKm      Int?
  
  // Pricing breakdown (for analysis)
  basePrice           Float?
  dynamicPrice        Float?                                // What algorithm calculated
  finalPrice          Float?                                // What customer actually paid
  appliedDiscount     Float?    @default(0)
  demandMultiplier    Float?
  seasonalMultiplier  Float?
  durationDiscount    Float?
  
  pricingSnapshotId   Int?
  pricingSnapshot     PricingSnapshot? @relation(fields: [pricingSnapshotId], references: [id])
  fuelLevelStartPct Int
  fuelLevelEndPct   Int?
  extraFees         Float         @default(0)
  notes             String?
}

model User {
  id            Int            @id @default(autoincrement())
  email         String         @unique
  passwordHash  String
  firstName     String?
  lastName      String?
  phoneNumber   String?
  role          Role           @default(USER)
  refreshTokens RefreshToken[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

enum Role {
  GUEST
  USER
  ADMIN
}

enum FuelType {
  PETROL
  DIESEL
  ELECTRIC
  HYBRID_HEV
  HYBRID_PHEV
}

enum Gearbox {
  MANUAL
  AUTOMATIC
}

enum BodyType {
  SEDAN
  HATCHBACK
  SUV
  WAGON
  COUPE
  CONVERTIBLE
  VAN
  PICKUP
}

enum CarState {
  AVAILABLE
  LEASED
  MAINTENANCE
}

enum ContractState {
  DRAFT
  ACTIVE
  COMPLETED
  CANCELLED
}

model Contact {
  id              Int                     @id @default(autoincrement())
  email           String
  phone           String
  operationAreas  ContactOperationArea[]
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt
}

model ContactOperationArea {
  id         Int      @id @default(autoincrement())
  contactId  Int
  contact    Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  cityId     Int
  city       City     @relation(fields: [cityId], references: [id], onDelete: Cascade)
  address    String?  // optional exact address for this city
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([contactId, cityId])
  @@index([contactId])
  @@index([cityId])
}

// New Parts model for car parts marketplace
model Part {
  id              Int         @id @default(autoincrement())
  // Mandatory fields
  make            String      // Car manufacturer (e.g., "BMW", "Toyota")
  model           String      // Car model (e.g., "320i", "Camry")
  year            Int         // Year of manufacture
  oem             String      // OEM part number
  partName        String      // Name of the part (e.g., "Front Bumper", "Headlight")
  
  // Optional fields
  engineCapacityL Float?      // Engine capacity in liters
  powerKW         Int?        // Power in kilowatts
  fuelType        FuelType?   // Fuel type (reusing enum)
  colour          String?     // Color of the part
  gearbox         Gearbox?    // Gearbox type (reusing enum)
  bodyType        BodyType?   // Body type (reusing enum)
  description     String?     @db.Text // Detailed description
  condition       PartCondition @default(USED)
  price           Decimal     @db.Decimal(10, 2)
  stockQuantity   Int         @default(1)
  
  images          PartImage[]
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@index([make, model])
  @@index([oem])
}

model PartImage {
  id        Int      @id @default(autoincrement())
  partId    Int
  part      Part     @relation(fields: [partId], references: [id], onDelete: Cascade)
  filename  String   // stored filename
  url       String   // public URL or path
  isMain    Boolean  @default(false)
  order     Int      @default(0)
  createdAt DateTime @default(now())

  @@index([partId])
}

enum PartCondition {
  NEW
  USED
  REFURBISHED
}

// Dynamic Pricing Models

model PricingSnapshot {
  id                    Int        @id @default(autoincrement())
  carId                 Int
  car                   Car        @relation(fields: [carId], references: [id], onDelete: Cascade)
  cityId                Int
  city                  City       @relation(fields: [cityId], references: [id])
  
  // Snapshot data
  calculatedPrice       Float
  basePrice             Float
  demandMultiplier      Float
  seasonalMultiplier    Float
  utilizationMultiplier Float
  durationMultiplier    Float
  customerMultiplier    Float      @default(1.0)
  finalPrice            Float
  
  // Context
  availableCars         Int                                 // How many cars were available
  activeContracts       Int                                 // How many were rented
  requestDate           DateTime
  startDate             DateTime
  duration              Int
  
  contracts             Contract[]
  createdAt             DateTime   @default(now())
  
  @@index([carId, createdAt])
  @@index([cityId, createdAt])
}

model CityDemandMetrics {
  id                  Int      @id @default(autoincrement())
  cityId              Int      @unique
  city                City     @relation(fields: [cityId], references: [id], onDelete: Cascade)
  
  // Current metrics (updated every 15 min)
  totalCars           Int
  availableCars       Int
  activeContracts     Int
  utilizationRate     Float                                 // % of fleet in use
  demandScore         Float                                 // 0.6 - 2.5
  
  // Historical averages (updated daily)
  avgUtilization30d   Float?
  avgUtilization90d   Float?
  avgPriceMultiplier  Float?
  
  lastCalculated      DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@index([lastCalculated])
}

model SeasonalFactor {
  id          Int      @id @default(autoincrement())
  name        String                                        // "Summer Peak", "Christmas Holiday"
  startDate   DateTime                                      // June 1
  endDate     DateTime                                      // August 31
  multiplier  Float                                         // 1.3 for 30% increase
  cityId      Int?                                          // Optional: specific to city
  city        City?    @relation(fields: [cityId], references: [id])
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  
  @@index([startDate, endDate, isActive])
}

model PricingRule {
  id          Int      @id @default(autoincrement())
  name        String
  description String?
  
  // Conditions
  carId       Int?                                          // Specific car, or null for all
  car         Car?     @relation(fields: [carId], references: [id], onDelete: Cascade)
  cityId      Int?                                          // Specific city, or null for all
  city        City?    @relation(fields: [cityId], references: [id])
  startDate   DateTime?
  endDate     DateTime?
  
  // Adjustments
  fixedPrice      Float?                                    // Override with fixed price
  multiplier      Float?                                    // Apply multiplier (e.g., 0.8 for 20% off)
  minPrice        Float?                                    // Override minimum
  maxPrice        Float?                                    // Override maximum
  
  priority    Int      @default(0)                          // Higher priority = applied first
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  
  @@index([startDate, endDate, isActive])
  @@index([priority])
}
